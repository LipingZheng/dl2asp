/*
 *  MUSbuilder.h  -  Class for constructing MUSes from MUS covers
 *  (referred to as MUS covers for historical reasons)
 *
 * by Mark H. Liffiton <liffiton @ eecs . umich . edu>
 *
 * Copyright (C) 2009, The Regents of the University of Michigan
 * See the LICENSE file for details.
 *
 */

#ifndef MUSBUILDER_H
#define MUSBUILDER_H

#include <list>
#include <set>

#include <hash_set>
#include <hash_map>

#include <vector>
#include <algorithm>
#include <time.h>
#include <stdio.h>
#include <sstream>

using namespace::std;

#define foreach(x,y,z)  for (x::iterator (y) = (z).begin() ; (y) != (z).end() ; (y)++)

typedef unsigned int Num;
typedef std::set<Num>  Cover;

#ifdef USING_STLPORT
typedef hash_map<Num,int> ClauseMap;
#else
typedef __gnu_cxx::hash_map<Num,int> ClauseMap;
#endif

//typedef vector<char>  ClauseAssign;
class ClauseAssign : public vector<char>
{
public:
    int numPos, numNeg;
    ClauseAssign() : numPos ( 0 ), numNeg ( 0 ) {}
};


// This simple hashing function (for building a hash table of ClauseAssign objects) works surprisingly well for this application
struct hashAssign {
    inline size_t operator() ( const ClauseAssign& s ) const {
        size_t h = 0;
        for ( ClauseAssign::const_iterator it = s.begin() ; it != s.end() ; it++ ) {
            h = ( h<<1 ) ^ *it;
        }
        return h;
    }
};

struct eqAssign {
    inline bool operator() ( const ClauseAssign& s1, const ClauseAssign& s2 ) const {
        // assumes they're the same length (safe *only* in this application)
        for ( unsigned int i = 0 ; i < s1.size() ; i++ ) {
            if ( s1[i] != s2[i] ) {
                //printf("N\n");
                return false;
            }
        }
        //printf("Y\n");
        return true;
    }
};

class MUSbuilder
{
public:
    MUSbuilder() :
        depth ( 0 ),
        verbose ( false ),
        reportEachTime ( false ),
        doBB ( false ),
        singletonsStr ( "" ),
        bbUpper ( 1000000000 ) // yeah, not great, but it'll do
    { }

    void setVerbose ( bool b )			{
        verbose = b;
    }
    void setReportEachTime ( bool b )	{
        reportEachTime = b;
    }
    void setDoBB ( bool b )			{
        doBB = b;
    }

    // Utility function:
    // Generate a mapping of clause names to numbers.  This ends up being a
    //  mapping of numbers to numbers, but it's important to "compress" the
    //  clause numbers into 0-n.  Additionally, the ordering does matter.  The
    //  code contains two possible orderings that produce different runtimes.
    static void generateMappingSorted ( const list<Cover>& MUSCovers, ClauseMap& clauseMapping, ClauseMap& clauseMappingRev );
    static void generateMappingStraight ( const list<Cover>& MUSCovers, ClauseMap& clauseMapping, ClauseMap& clauseMappingRev );

    // Utility function:
    // Translate clauses based on the mapping generated by generateMapping*().
    static void translateClauses ( list<Cover>& MUSCovers, ClauseMap& clauseMapping );

    void addClauseMapping ( ClauseMap& newClauseMappingRev ) {
        clauseMappingRev = newClauseMappingRev;
    }
    void addSingletons ( vector<Num>& newSingletons ) {
        if ( newSingletons.empty() ) {
            return;
        }
        singletons = newSingletons;
        // make a string of it, too -- to save time when outputting
        ostringstream o;
        foreach ( vector<Num>, it, singletons ) {
            o << *it << " ";
        }
        singletonsStr = o.str();
    }

    // The main, recursive function
    bool constructMUS ( list<Cover> covers, ClauseAssign curAssign );


private:
    unsigned int depth;
    bool verbose;
    bool reportEachTime;
    bool doBB;
    vector<Num> singletons;
    string singletonsStr;

    int bbUpper;

#ifdef USING_STLPORT
    hash_set< ClauseAssign , hashAssign , eqAssign > beenHere;
#else
    __gnu_cxx::hash_set< ClauseAssign , hashAssign , eqAssign > beenHere;
#endif

    ClauseMap clauseMappingRev;	// new to original numbers

    void removeClauseAndCover ( list<Cover>& covers, ClauseAssign& curAssign, Num clause, const Cover& cover );
    inline bool removeClause ( list<Cover>& covers, Num clause, ClauseAssign& assign );
    inline bool isVisited ( const ClauseAssign& curAssign );
    inline void maintainNoSubsets ( list<Cover>& covers, const Cover& modCover );
    inline int mapToOrig ( Num clause ) {
        return clauseMappingRev[clause];
    }
    inline void outputMUS ( ClauseAssign& curAssign );
    inline void propagateSingletons ( list<Cover>& covers, ClauseAssign& curAssign );

    inline int mis_quick ( list<Cover> covers );
};

#endif
